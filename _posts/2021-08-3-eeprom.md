---
layout: post
title:  "Arduino EEPROM programmer"
date:   2021-08-3 00:51:00 +0200
categories: arduino
tags: project
---
{% include math.html %}
<!--more-->

# Table of Contents
- [Table of Contents](#table-of-contents)
  - [Pre-requisites](#pre-requisites)
  - [Arduino nano setup](#arduino-nano-setup)
    - [Windows 10 USB driver](#windows-10-usb-driver)
  - [Digital pins](#digital-pins)
    - [Shift register](#shift-register)
    - [74HC595 (8-bit shift register)](#74hc595-8-bit-shift-register)
      - [8-bit Storage register](#8-bit-storage-register)
  - [Testing Arduino and two 8-bit shift registers](#testing-arduino-and-two-8-bit-shift-registers)
    - [Tinkercad](#tinkercad)
  - [EEPROM Address](#eeprom-address)
  - [EEPROM data input](#eeprom-data-input)
  - [Community comments](#community-comments)

<iframe width="100%" height="415" src="https://www.youtube.com/embed/K88pgWhEb1M" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

## Pre-requisites
* You'll need to have a way to debug the EEPROM, such as the [program/debug breadboard circuit]({{ site.url }}/hardware/2021/06/26/8-bit-computer.html#breadboard-circuit-to-programdebug-the-eeprom) of the [Ben Eater 8-bit computer project]({{ site.url }}/hardware/2021/06/26/8-bit-computer.html)

![404]({{ site.url }}/images/8bit/output/eeprom2.PNG)
[Open tinkercad](https://www.tinkercad.com/things/1NAGZ3Yxxzh-eeprom-programmer)

* You'll also need to be familiar with bitwise operations and object oriented programming. For a refresher you can check [CSE1100 (Objected oriented programming (in Java))]({{ site.url }}/downloads/CSE1100_(java_oop-lectures-tutorials-assignments).pdf). 

## Arduino nano setup
* The goal is to automatically set the address, data, write enable/output enable pins for each write operation
* We're gonna use the arduino nano, although the arduino uno could be used as well.
  * The tinkercad implementation will be with arduino uno as nano is not available there.
  * nano has the same functionalities but in a smaller form and it's more compact
* It can be plugged directly into the breadboard and it comes with a USB port that can be connected to the computer to power up the microcontroller.
  * Nano provides 5V and ground pins, so we can use them to power up the rest of the breadboard!
* To check if the microcontroller is working properly you can verify and upload the following code from [Arduino's IDE](https://www.arduino.cc/en/software) into the nano:

```c++
void setup() {
  // initialize digital pin LED_BUILTIN as an output.
  pinMode(LED_BUILTIN, OUTPUT);
}

// the loop function runs over and over again forever
void loop() {
  digitalWrite(LED_BUILTIN, HIGH);
  delay(1000);
  digitalWrite(LED_BUILTIN, LOW);
  delay(1000);
}
```

### Windows 10 USB driver
* Tip: Double check the microcontroller that you bought. Ben's kit came up with a CH340 nano, not an Arduino nano, therefore the USB drivers that came with Arduino's IDE did not work. I had to install the [drivers for CH340 Nano](https://learn.sparkfun.com/tutorials/how-to-install-ch340-drivers/all#windows-710) manually. Below what you could do with windows 10 and CH340 Nano:
  * Download the [Driver v3.4 (2016-09-27)]({{ site.url }}/downloads/Windows-CH340-Driver.zip)
  * Install [Arduino 1.8.15](https://www.arduino.cc/en/software)
  * Re-start the laptop
  * Turn off Bluetooth
  * Select the only port available (COM6 for the CH340 Nano)
  * Under "Tools" select Arduino Nano as the "Board"
  * Under "Tools" select ATmega328P (Old bootloader) as the processor
  * Keep AVRISP mkll as the programmer
  * Upload first the bare minimum example and then Blink from (File > Examples > Basics > Blink)
![404]({{ site.url }}/images/8bit/output/upload.PNG)

## Digital pins
* Nano comes with the 12 data pins we can control while using the USB interface:
  1. D2
  2. D3
  3. D4
  4. D5
  5. D6
  6. D7
  7. D8
  8. D9
  9. D10
  10. D11
  11. D12
  12. D13
* RXO and TX1 cannot be used with the USB serial interface.
  * We need to use the USB interface not only to power the circuit but also to be able to read the EEPROM and display it on our laptop/pc.
* However we have a total of 21 EEPROM pins we need to configure:
  * 11 address pins
  * 8 data pins
  * Write enable
  * Output enable

### Shift register
* We can control many signals with just a few pins by using shift registers
* A shift register is essentially a combination of D flip-flops in series where the input of \\(D_n\\) is the output of \\(D_{n-1}\\) (Big Endian).
* At each clock pulse the data bits are shifted one position to the right.
* Because the shift register has just a single input (and the clock) but as many outputs as you want it's very useful for scenarios where a microcontroller has less output pins that you need.

### 74HC595 (8-bit shift register)
![404]({{ site.url }}/images/8bit/output/74HC595.PNG)
The only inputs we care about:
* DS = data serial input
* SH_CP = shift clock pulse

#### 8-bit Storage register
* The 74HC595 comes with an internal register that stores the contents between the shift register and the output pins
* Pin 12 (ST_CP) is the storage clock pulse.
  * Behaves like an output "update" (rather than enable) signal. It is active high.

## Testing Arduino and two 8-bit shift registers
1. Insert the arduino nano on the breadboard
   * Connect 5V and GND pins to the power rails
2. Insert 2 74HC595 8-bit shift registers
   * Hookup power and ground pins
   * Tie \\(\overline{MR}\\) (master reset) high
   * Tie \\(\overline{OE}\\) low
3. Comming from the arduino we'll have:
   * D2 of nano <-> DS (serial data) of left 74HC595
     * `#define SHIFT_data 2`
   * D3 of nano <-> SH_CP (Shift register clock) of left and right 74HC595
     * `#define SHIFT_CLK 3`
   * D4 of nano <-> ST_CP (storage rester clock) of left and right 74HC595
     * `#define SHIFT_CLK 4`
   * These `#define constant n` with \\(n\\) as a number from 2 to 13 snippets is the way to define a constant in arduino code for the data pin n of the arduino board.
4. Hookup the Q7' pin (serial data output, aka LSB Big Endian) of the left 8-bit shift register with the right one DS (serial data) input
5. Hookup 11 MSB output pins to LEDs with resistors in series
6. Upload the code below to the nano with the steps described at [Arduino nano setup](#arduino-nano-setup)
  * What we want to do is to set D2 (data input) with a specific value and alternate D3 (clock signal) high and low at a certain rate
  * We could either manually program high and low bits for a pulse with a for loop, and set output high/low data pins in binary at the same rate, or use a built-in function that does it for us, (outputting and clocking) namely shiftOut() shifts out a byte of data one bit at a time.
    * `shiftOut(dataPin, clockPin, bitOrder, value)`
    * (int) `dataPin`: the pin on which to output each bit i.e. `SHIFT_DATA`
    * (int) `clockPin`: the pin to toggle once the dataPin has been set to the correct value.
    * `bitOrder`: which order to shift out bits; either `MSBFIRST` or `LSBFIRT`.
      * Since the value is a byte, whichever value you use between 0 and 255 will be turned into binary and padded with 0s such that you have 8 digits. LSBFIRT will display it in little endian (aka normal) and MSBFIRST the other way around.
    * (byte) `value` the data to shift out 
  * We still need to manually trigger the storage/output clock to see the results. `digitalWrite(pin, HIGH/LOW)` function does it for us.
    * going from low, to high, to low should do the trick.

```c++
//Constants
#define SHIFT_DATA 2
#define SHIFT_CLK 3
#define SHIFT_LATCH 4

//Run only once
void setup(){
  //Set our constants (D2, D3 and D4) as output pins
  pinMode(SHIFT_DATA, OUTPUT);
  pinMode(SHIFT_CLK, OUTPUT);
  pinMode(SHIFT_LATCH, OUTPUT);

  //Shift LSBFIRST (output is displayed the same you write here)
  // LS shift register also comes first
  // Reminder that we only use it's 3 MSB bits,
  // shiftOut works at byte level
  // To output all 1's we just need:
  shiftOut(SHIFT_DATA, SHIFT_CLK, LSBFIRST, 0b11100000);
  shiftOut(SHIFT_DATA, SHIFT_CLK, LSBFIRST, 0b11111111);
  

//Trigger a clock pulse for the output clock signal
  digitalWrite(SHIFT_LATCH, LOW);
  digitalWrite(SHIFT_LATCH, HIGH);
  digitalWrite(SHIFT_LATCH, LOW);
}

void loop() {

}
```

* Think of OUTPUT/INPUT as the value of the DIR pin of the tri-state buffers that we had for the registers.
  * We will have some sort of "BUS" between the 8-bit shift registers (controlled by the nano) and the EEPROM I/O pins.
  * We only want to have 1 party outputting to the the BUS (aka driving), so output enable of EEPROM has to be turned off before we run `void setup()` with all the `pinMode(pin_n, OUTPUT)`.
  * If one of them (arduino or EEPROM) is trying to drive a zero on a particular bit and the other is trying to drive a one then you will effectively have a short from the positive power rail, through the output driver of (say) the EEPROM onto the bus and then down through the output driver of the Arduino to the ground rail.
  * The output impedance of the devices can be quite low and so quite a large current can flow, this can cause the output drivers of both devices to be damaged.
    * In the program this would only happen for a very short time (nanoseconds) and so the devices probably would be ok as there wouldn't be time for heat to build up, but if, for example, you were single stepping through the code, it could be in that state for quite some time and damage could easily occur.  Best practise is to ensure there is only one device driving the bus at any one time.
* For now we don't have a BUS, just LEDs with resistors.

### Tinkercad
![404]({{ site.url }}/images/8bit/output/tinker3.PNG)
[Open tinkercad](https://www.tinkercad.com/things/bt4z9u2dtL1-arduino-shift-test)

## EEPROM Address
* Once the implementation of storing 11 bits into the shift registers has worked, we can refactor the `setup()` code regarding the storage off 11 bits into `setAddress(int address)` and the output clock pulse into, which is used to latch the shift register content into the shift register output pins, as `latch()`.

```c++
/**
* Triggers a clock pulse for the shift register output clock signal
*/
void latch(){
  digitalWrite(SHIFT_LATCH, !digitalRead(SHIFT_LATCH));
  digitalWrite(SHIFT_LATCH, !digitalRead(SHIFT_LATCH));
}

/**
* Sets the address in little endian by splitting it into right and left register
*/
void setAddress(int address) {
  int rightRegister = address & 0b00000000111; 
  int leftRegister = address & 0b11111111000;
  shiftOut(SHIFT_DATA, SHIFT_CLK, LSBFIRST, rightRegister << 5); //3 LSB significant bits padded with 5 zeros to the right
  shiftOut(SHIFT_DATA, SHIFT_CLK, LSBFIRST, leftRegister >> 3); //8 most significant bits (of an 11bit address)
  latch();
}
```
* Ben Eater address implementation uses the most significant LED to store the least significant bit. That's what I've been calling "Big Endian" so far in the [8-bit computer project]({{ site.url }}/hardware/2021/06/26/8-bit-computer.html).
* Although its display is inverted (if you input address `0b00000000001`, you'd see lighting up the leds in the fashion `10000000000`, it's address method implation is much cleaner and the bits actually line up with the outpin numbers of the 8-bit shift register datasheet:

```c++
void setAddress(int address) {
  shiftOut(SHIFT_DATA, SHIFT_CLK, MSBFIRST, address >> 8);
  shiftOut(SHIFT_DATA, SHIFT_CLK, MSBFIRST, address);
  latch();
}
```
* We're going to go with Ben's style as it will probably fit better with the breadboard pin layout he has prepared.
* On top of this, Ben also wants to use the LSB (in terms of leds, but rather the 8th output pin) of the "register on the left" as the signal for \\(\overline{OE}\\) of the EEPROM.
  * For that we will bitwise sum the data input for the first shiftOut (the one that'll end up on the register on the left) with either a 1 or a 0 in the binary most signicant position such that it ends up in the 8th output pin of the second register, since it's active low, we sum 0 if it's `true` and 128 (0b10000000, which ends up with the 1 at 0b00000001, that is the 8th output pin) if it's `false`. 

```c++
void setAddress(int address, bool outputEnable) {
  shiftOut(SHIFT_DATA, SHIFT_CLK, MSBFIRST, (address >> 8) | (outputEnable ? 0 : 128));
  shiftOut(SHIFT_DATA, SHIFT_CLK, MSBFIRST, address);
  latch();
}
```
* Continue the video at 28:00 
* Do the connection of address cables, then move onto next section (data and write enable)

## EEPROM data input







## Community comments

---

just thought I’d point out that the issue you saw with your incorrect read following write, is because you didn’t implement the (not)DATA POLLING, outlined in the 28C16 data sheet. 
ie. "The AT28C16 provides DATA POLLING to signal the completion of a write cycle.”  
DATA POLLING uses the inversion of the most significant bit (when a post write read is performed) to indicate the write busy state. Please also note that the other read bits (other than MSB), are indeterminate during the data polling busy state.
So when you saw two subsequent reads of 0x81 after writing 0x2A, you’ll note the byte you wrote (0x2A) has a 0 MSB, and the read value (0x81) has a 1 MSB (ie. inverted 0 indicating busy state). The remaining bits of the 0x81 byte being indeterminate.
By the third byte read, the busy state was complete, and the 3rd address data byte, and onwards, were then correctly retrieved. 
Likewise, the same can be seen with your second attempt to write 0x00, where you then read 0xAA bytes.  Again, note the MSB is inverted from 0 to 1, to indicate data polling busy state.
In summary: Although the Write Cycle Time is spec’d as max 1ms, you really shouldn’t just assume a 1ms delay will do the trick. The correct implementation would be to perform a read loop after a write, to poll for a non inverted MSB of the byte just written, to await busy state completion.