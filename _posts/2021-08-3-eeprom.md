---
layout: post
title:  "Arduino EEPROM programmer"
date:   2021-08-3 00:51:00 +0200
categories: arduino
tags: project
---
{% include math.html %}
<!--more-->

# Table of Contents
- [Table of Contents](#table-of-contents)
  - [Pre-requisites](#pre-requisites)
  - [Community comments](#community-comments)
  - [Tinkercad](#tinkercad)

<iframe width="100%" height="415" src="https://www.youtube.com/embed/K88pgWhEb1M" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

## Pre-requisites
* You'll need to have a way to debug the EEPROM, such as the [program/debug breadboard circuit]({{ site.url }}/hardware/2021/06/26/8-bit-computer.html#breadboard-circuit-to-programdebug-the-eeprom) or the [8-bit decimal display]({{ site.url }}/hardware/2021/06/26/8-bit-computer.html#8-bit-decimal-display) of the [Ben Eater 8-bit computer project]({{ site.url }}/hardware/2021/06/26/8-bit-computer.html)

## Community comments
Currently in the write eeprom routine you set all the arduino pins to outputs and then set the address and turn the output enable off.  If you had previously read the eeprom then the output enable would be active and for a very short time the eeprom's data lines would be driving the bus and the arduino pins would be as well causing contention on the bus and possible damage. 

Ben Eater
Ben Eater
4 years ago
Good catch! You're absolutely right; that's something I overlooked. I just updated the code here to fix that issue: https://github.com/beneater/eeprom-programmer
282
Adam Oakley
Adam Oakley
4 years ago
What are the negative side effects of doing that?
23
Graham Smith
Graham Smith
4 years ago
Hi Adam, the problem is that if the output enable on the EEPROM is still active when you set the arduino pins to be outputs then both the EEPROM and the arduino will be trying to drive the bus at the same time.  If one of them is trying to drive a zero on a particular bit and the other is trying to drive a one then you will effectively have a short from the positive power rail, through the output driver of (say) the EEPROM onto the bus and then down through the output driver of the Arduino to the ground rail.  The output impedance of the devices can be quite low and so quite a large current can flow, this can cause the output drivers of both devices to be damaged.  In the program this would only happen for a very short time (nanoseconds) and so the devices probably would be ok as there wouldn't be time for heat to build up, but if, for example, you were single stepping through the code, it could be in that state for quite some time and damage could easily occur.  Best practise is to ensure there is only one device driving the bus at any one time.
200


---

just thought I’d point out that the issue you saw with your incorrect read following write, is because you didn’t implement the (not)DATA POLLING, outlined in the 28C16 data sheet. 
ie. "The AT28C16 provides DATA POLLING to signal the completion of a write cycle.”  
DATA POLLING uses the inversion of the most significant bit (when a post write read is performed) to indicate the write busy state. Please also note that the other read bits (other than MSB), are indeterminate during the data polling busy state.
So when you saw two subsequent reads of 0x81 after writing 0x2A, you’ll note the byte you wrote (0x2A) has a 0 MSB, and the read value (0x81) has a 1 MSB (ie. inverted 0 indicating busy state). The remaining bits of the 0x81 byte being indeterminate.
By the third byte read, the busy state was complete, and the 3rd address data byte, and onwards, were then correctly retrieved. 
Likewise, the same can be seen with your second attempt to write 0x00, where you then read 0xAA bytes.  Again, note the MSB is inverted from 0 to 1, to indicate data polling busy state.
In summary: Although the Write Cycle Time is spec’d as max 1ms, you really shouldn’t just assume a 1ms delay will do the trick. The correct implementation would be to perform a read loop after a write, to poll for a non inverted MSB of the byte just written, to await busy state completion.
## Tinkercad