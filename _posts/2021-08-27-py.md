---
layout: post
title:  "Python and Numpy cheatsheet"
date:   2021-08-27 00:51:00 +0200
categories: datascience
tags: cheatsheet python CSE2510
---
{% include math.html %}
<!--more-->

*This is a summary of the first CSE2510 Machine Learning lab*

# Table of Contents
- [Table of Contents](#table-of-contents)
  - [Java vs Python](#java-vs-python)
  - [Python program files on Unix](#python-program-files-on-unix)
  - [Modules](#modules)
  - [Variables and types](#variables-and-types)
    - [Type casting](#type-casting)
  - [Operators and comparisons](#operators-and-comparisons)
  - [Compound types](#compound-types)
    - [Strings](#strings)
    - [String formatting](#string-formatting)
    - [Lists](#lists)
    - [Adding, inserting, modifying, and removing elements from lists](#adding-inserting-modifying-and-removing-elements-from-lists)
    - [Tuples](#tuples)
    - [Dictionaries](#dictionaries)
  - [Control Flow](#control-flow)
    - [Conditional blocks](#conditional-blocks)
    - [Loops](#loops)
    - [While loops](#while-loops)
  - [Functions](#functions)
  - [Classes](#classes)
  - [Exceptions](#exceptions)

## Java vs Python
Unlike in Java, in Python, we do not use the semicolon ;, nor curly brackets {} to denote code blocks. Instead, a line break denotes the end of a statement and indentation is used to denote code blocks. Take the following Java method:

```java
public void foo(boolean bar) {
    if (bar) {
        System.out.println("Hello world");
    } else {
        System.out.println("42");
    }
}
```

In Python, this would be written as:

```python
def foo(bar):
    if bar:
        print("Hello World")
    else:
        print("42")
```

## Python program files on Unix

* Python code is usually stored in text files with the file ending ".py": `myprogram.py`
* Every line in a Python program file is assumed to be a Python statement, or part thereof.
  * The only exception is comment lines, which start with the character `#` (optionally preceded by an arbitrary number of white-space characters, i.e., tabs or spaces). Comment lines are ignored by the Python interpreter.
* To run our Python program from the command line, use:

```bash
      $ python myprogram.py
```

* On UNIX systems it is common to define the path to the interpreter on the first line of the program (note that this is a comment line as far as the Python interpreter is concerned):

```python
      #!/usr/bin/env python
```

* If we do, and if we additionally set the file script to be executable, we can run the program like this:

```bash
      $ myprogram.py
```

## Modules
* Most of the functionality in Python is provided by modules. The Python Standard Library is a large collection of modules that provides cross-platform implementations of common facilities such as access to the operating system, file I/O, string management, network communication, and much more.
* To use a module in a Python program it first has to be imported. A module can be imported using the import statement. To import the module math, which contains many standard mathematical functions, we can do:

```python
import math
```

* This includes the whole module and makes it available for use later in the program. For example, we can write the following program using the math module:

```python
import math

math.cos(2 * math.pi)
```

* Alternatively, we can choose to import all symbols (functions and variables) in a module to the current namespace (so that we don't need to use the prefix "math." every time we use something from the math module):

```python
from math import *

cos(2 * pi)
```

* This pattern can be very convenient, but in large programs that include many modules it is often a good idea to keep the symbols from each module in their own namespaces, by using the import math pattern. This would eliminate potentially confusing problems with name space collisions.
* As a third alternative, we can choose to import only a few selected symbols from a module by explicitly listing which ones we want to import instead of using the wildcard character *:

```python
from math import cos, pi

cos(2 * pi)
```

* Once a module is imported, we can list the symbols it provides using the dir function:

```python
import math

​dir(math)
```

Which returns: ['\__doc__', '\__loader__', '\__name__', '\__package__', '\__spec__', 'acos', 'acosh', 'asin'...]

* And using the function help we can get a description of each function (almost .. not all functions have docstrings, as they are technically called, but the vast majority of functions are documented this way).

```python
help(math.log)
```
```
Help on built-in function log in module math:

log(...)
    log(x, [base=math.e])
    Return the logarithm of x to the given base.
    
    If the base not specified, returns the natural logarithm (base e) of x.
```

* We can also use the help function directly on modules i.e. `help(math)`
* Some very useful modules form the Python standard library are os, sys, math, shutil, re, subprocess, multiprocessing, threading. 

* We can (and should) create our own modules that abstract/refactor functionalities into a `.py` file (module).
  * While functions and classes (within a file) are examples of tools for low-level modular programming. Python *modules* are a higher-level modular programming construct, where we can collect related variables, functions and classes in a module.
  * Like the Python libraries, you import your own modules with the `import` statement
* Consider the following example: the file `mymodule.py` contains simple example implementations of a variable, function and a class:

```py
%%file mymodule.py
"""
Example of a Python module. Contains a variable called my_variable,
a function called my_function, and a class called MyClass.
"""
my_variable = 0

def my_function():
    """
    Example function
    """
    return my_variable
    
class MyClass:
    """
    Example class.
    """
​
    def __init__(self):
        self.variable = my_variable

    def set_variable(self, new_value):
        """
        Set self.variable to a new value
        """
        self.variable = new_value

    def get_variable(self):
        return self.variable
```

* We can import the module mymodule into other program with:

```py
%load_ext autoreload
%autoreload 2 # This makes sure all modules are reloaded every time before executing the Python code typed.

import mymodule
```

## Variables and types
* Variable names in Python can contain alphanumerical characters a-z, A-Z, 0-9 and some special characters such as _. Normal variable names must start with a letter.
* By convention, variable names start with a lower-case letter, and Class names start with a capital letter. Another convention is to use the lower dash _ to separate words, instead of camelcase. E.g. instead of myVariable, we tend to write my_variable. For further code style guidlines, you can check out Google's style guides for python: [http://google.github.io/styleguide/pyguide.html](http://google.github.io/styleguide/pyguide.html)
* In addition, there are a number of Python keywords that cannot be used as variable names. These keywords are:
  * and, as, assert, break, class, continue, def, del, elif, else, except, 
exec, finally, for, from, global, if, import, in, is, lambda, not, or,
pass, print, raise, return, try, while, with, yield

* The assignment operator in Python is `=`. Like Javascript, python is a dynamically typed language, so we do not need to specify the type of a variable when we create one. The type is derived from the value it was assigned.

Assigning a value to a new variable creates the variable:

```python
# variable assignments
x = 1.0
my_variable = 12.2

type(x) # check the type (returns "int")
```

* If we assign a new value to a variable, its type can change.

```python
x =[1,2,3,4,5]
type(x) # should return "list"
```

* If we try to use a variable that has not yet been defined we get a NameError:

```python
y
```

returns:

```
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-13-9063a9f0e032> in <module>
----> 1 y

NameError: name 'y' is not defined
```

* Python has four primitive or fundamental data types, namely, integers, floats, booleans and strings. Other types such as complex numbers are also supported:

```python
# complex numbers: note the use of `j` to specify the imaginary part
type(1.0 - 1.0j) # should return "complex"
```

### Type casting

Examples of type casting in Python are shown below.

```python
x = 1.5
​print(x, type(x))

x = int(x)
​print(x, type(x))

z = complex(x)
print(z, type(z))

x = float(z)
```

```
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-24-19c840f40bd8> in <module>
----> 1 x = float(z)

TypeError: can't convert complex to float
```

* Complex variables cannot be cast to floats or integers. We need to use `z.real` or `z.imag` to extract the part of the complex number we want:

```python
y = bool(z.real)

​print(z.real, " -> ", y, type(y))

y = bool(z.imag)

print(z.imag, " -> ", y, type(y))
```

```
1.0  ->  True <class 'bool'>
0.0  ->  False <class 'bool'>
```

## Operators and comparisons
* Arithmetic operators +, -, *, /, // (integer division), % (modulo), ** power
* The boolean operators are spelled out as words: and, not, or.

```python
True and False
```
`False`

```python
not False
```
`True`

```python
True or False
```
`True`

* Comparison operators >, <, >= (greater or equal), <= (less or equal), == (equality), is (identical as if same memory address)

```python
# equality
[1,2] == [1,2]
```
`True`

```python
# objects identical (same memory adress)?
o1 = [1,2]
o2 = [1,2]

o1 is o2
```
`False`

## Compound types
### Strings
* Strings are the variable type that is used for storing text.

```python
s = "Hello world"
type(s)
```
```python
str.capitalize('abcd') #'Abcd'
```
```python
# length of the string: the number of characters including spaces
len(s)
```
```python
# replace a substring in a string with something else
s2 = s.replace("world", "test")
print(s2)
```
```
Hello test
```

* We can index a character in a string using []:

```python
s[0]
```
`H`

* Unlike MATLAB, indexing start at 0!
* We can extract a part of a string using the syntax [start:stop], which extracts characters between index start and stop, including the start element and excluding the stop element: [start, stop).

* If we do not define start or stop in [start:stop], e.g. [:stop], start will default to 0 and end to the end of the string.

```python
s[:5]
```
`Hello`
```python
s[6:]
```
`world`
```python
s[:]
```
`Hello world`

* We can also define the step size using the syntax [start:end:step] (the default value for step is 1, as we saw above). This technique is called slicing.

```python
s[::1]
```
`Hello world`
```python
s[::2]
```
`Hlowrd`

### String formatting
```python
print("str1", "str2", "str3")  # The print statement concatenates strings with a space

print("str1", 1.0, False, -1j)  # The print statements converts all arguments to strings

print("str1" + "str2" + "str3") # strings added with + are concatenated without space
```
```python
print("value = %f" % 1.0)       # we can use C-style string formatting
```
`value = 1.000000`
```python
s2 = "value1 = %.2f. value2 = %d" % (3.1415, 1.5) # returns: value1 = 3.14. value2 = 1

# alternative, more intuitive way of formatting a string 
s3 = 'value1 = {0}, value2 = {1}'.format(3.1415, 1.5) # returns: value1 = 3.1415, value2 = 1.5
```

### Lists
* Lists are very similar to strings, except that each element can be of any type.
* The syntax for creating lists in Python is [value_1,value_2, ... ,value_n]:

```python
l = [1,2,3,4]
print(type(l))
print(l)
```

```
<class 'list'>
[1, 2, 3, 4]
```

* We can use the same slicing techniques to manipulate lists as we could use on strings:

```python
print(l)
print(l[1:3])
print(l[::2])
```
```
[1, 2, 3, 4]
[2, 3]
[1, 3]
```

* Elements in a list do not all have to be of the same type. However, to avoid errors, it is advised to store only values of one type in a list:
* Python lists can be inhomogeneous and arbitrarily nested:

```python
nested_list = [1, [2, [3, [4, [5]]]]]
```

* Lists play a very important role in Python, and are used in loops and other flow control structures (discussed below). There are a number of convenient functions for generating lists of various types, for example the range function:

```python
start = 10
stop = 30
step = 2

​range(start, stop, step) # range(10, 30, 2)

# in python 3 range generates an iterator, which can be converted to a list using 'list(...)'.

list(range(start, stop, step))
```
`[10, 12, 14, 16, 18, 20, 22, 24, 26, 28]`

```python
list(range(-10, 10)) # no step means step = 1
```
`[-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`

* convert a string to a list by type casting:

```python
s = 'Hello world'
s2 = list(s) #= ['H', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']
```

* sorting lists, uppercase and lowercase characters are sorted separately

```python
s2.sort()
print(s2)
```
`[' ', 'H', 'd', 'e', 'l', 'l', 'l', 'o', 'o', 'r', 'w']`

### Adding, inserting, modifying, and removing elements from lists
* create a new empty list with `l = []`
* add an elements using `append`

```python
l.append("A")
l.append("d")
l.append("d")
print(l)
```
`['A', 'd', 'd']`

* We can modify lists by assigning new values to elements in the list. In technical jargon, lists are mutable.

```python
l[1] = "p"
l[2] = "p"
print(l)
```
`['A', 'p', 'p']`

* Insert an element at an specific index using insert

```python
l.insert(0, "i")
l.insert(1, "n")
l.insert(2, "s")
l.insert(3, "e")
l.insert(4, "r")
l.insert(5, "t")
```
* Remove first element with specific value using 'remove': `l.remove("A")`
* Remove an element at a specific location using del: `del l[7]`
* See help(list) for more details, or read the online documentation

### Tuples
* Tuples are like lists, except that they cannot be modified once created, that is they are immutable.
* In Python, tuples are created using the syntax (..., ..., ...):

```python
point = (10, 20)
print(point, type(point))
```
```
(10, 20) <class 'tuple'>
```

* We can unpack a tuple by assigning it to comma-separated variables:

```python
x, y = point
print("x =", x)
print("y =", y)

x = 10
y = 20
```

* If we try to assign a new value to an element in a tuple we get an error:

```python
point[0] = 20
```
```
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-70-9734b1daa940> in <module>
----> 1 point[0] = 20

TypeError: 'tuple' object does not support item assignment
```

### Dictionaries
* Dictionaries are also like Java objects. The values are connected to keys of the dictionary. The keys can be used to retrieve values from a dictionary. The syntax for dictionaries is {key1 : value1, ...}:

```python
 values = {

     "key1" : 1.0,

     "key2" : 2,

     "key3" : [1,2,3]

 }

​print(type(values))
print(values)
```
```
<class 'dict'>
{'key1': 1.0, 'key2': 2, 'key3': [1, 2, 3]}
```

* Retrieve a value by using the key

```python
values["key1"]
```
`1.0`

* You can reassign the values corresponding to a key

```python
values["key1"] = "A"
values["key2"] = "B"
values["key4"] = "D" # Assigning a value to an unknown key results in the creation of that key

print("key1 = ", values["key1"])
print("key2 = ", values["key2"])
print("key3 = ", values["key3"])
print("key4 = ", values["key4"])
```
```
key1 =  A
key2 =  B
key3 =  [1, 2, 3]
key4 =  D
```

## Control Flow
### Conditional blocks
* The Python syntax for conditional execution of code use the keywords if, elif (else if), else
* Program blocks are defined by their indentation level.

```python
statement1 = False
statement2 = False

if statement1:
    print("statement1 is True")

elif statement2:
    print("statement2 is True")

else:
    print("statement1 and statement2 are False")
```

### Loops
* In Python, loops can be programmed in a number of different ways. The most common is the for loop, which is used together with iterable objects with in, such as lists. The basic syntax is:
for loops:

```python
for x in [1,2,3]:
    print(x)
```


* The for loop iterates over the elements of the supplied list, and executes the containing block once for each element.
* Any kind of list can be used in the for loop:

```python
for x in range(4): # by default range start at 0
    print(x)
```

* To iterate over key-value pairs of a dictionary one can also jus use in:

```python
 values = {
     "key1" : 1.0,
     "key2" : 2,
     "key3" : [1,2,3]
 }
​
for key, value in values.items():
    print(key + " = " + str(value))
```

* Sometimes it is useful to have access to the indices of the values when iterating. We can use the enumerate function for this:

```python
for index, x in enumerate(range(-3,3)):
    print(index, x)
```

* A convenient and compact way to initialize lists can be done with for loops:

```python
l1 = [x**2 for x in range(0,5)] # yikes
print(l1)
```
`[0, 1, 4, 9, 16]`

### While loops
* It's your job to update the conditional variable such that to not end up with an infinite loop

```python
i = 0

while i < 5:
    print(i)
    i = i + 1
```

## Functions
* A function (method in Java) in Python is defined using the keyword `def`, followed by a function name, a signature (lists the parameters) within parentheses `()`, and a colon `:`. The following code, with one additional level of indentation, is the function body.

```py
def func0():   
    print("func0 is called")

func0()
```
`func0 is called`

* Optionally, but highly recommended, we can define a so called "docstring", which is a description of the function's purpose and behaivor. The docstring should follow directly after the function definition, before the code in the function body.

```py
def func1(s):
    """
    Print a string 's' and tell how many characters it has    
    """
    print(s + " has " + str(len(s)) + " characters")

help(func1)
```
```
Help on function func1 in module __main__:
func1(s)
    Print a string 's' and tell how many characters it has
```

* Functions that return a value use the return keyword (see that the fuction keywords remain the same):

```py
def square(x):
    """
    Return the square of x.
    """
    return x ** 2
```

* We can return multiple values from a function using tuples (see above):

```py
def powers(x):
    """
    Return a few powers of x.
    """
    return x ** 2, x ** 3, x ** 4
```
```py
print(powers(3))
```
`(9, 27, 81)`
```py
x2, x3, x4 = powers(3)
print(x3)
```
`27`

* In a definition of a function, we can give default values to the arguments the function takes:
  * If we don't provide a value of the debug argument when calling the the function myfunc it defaults to the value provided in the function definition

```py
def myfunc(x, p=2, debug=False):
    if debug:
        print("evaluating myfunc for x = " + str(x) + " using exponent p = " + str(p))
    return x**p
```

* If we explicitly list the name of the arguments in the function calls, they do not need to come in the same order as in the function definition. This is called keyword arguments, and is often very useful in functions that takes a lot of optional arguments: `myfunc(p=3, debug=True, x=7)`
* In Python we can also create unnamed functions, using the lambda keyword:

```py
f1 = lambda x: x**2
# is equivalent to 
def f2(x):
    return x**2
```

* This technique is useful for example when we want to pass a simple function as an argument to another function, like this:

```py
# map is a built-in python function
map(lambda x: x**2, range(-3,4))

# in python 3 we can use `list(...)` to convert the iterator to an explicit list
list(map(lambda x: x**2, range(-3,4)))
```
`[9, 4, 1, 0, 1, 4, 9]`

## Classes
* A class is a structure for representing an object and the operations that can be performed on the object.
* In Python a class can contain attributes (variables) and methods (functions).
* A class is defined almost like a function, but using the class keyword, and the class definition usually contains a number of class method definitions (a function in a class).
  * Each class method should have an argument `self` as it first argument. This object is a self-reference. (like `this` in java, but turns out python requires you to explicitly pass it as first argument)
  * Some class method names have special meaning, for example:
    * \__init__: The name of the method that is invoked when the object is first created (like a constructor in java)
    * \__str__ : A method that is invoked when a simple string representation of the class is needed, as for example when printed. (toString() in java)
    * There are many more

```py
class Point:
    """
    Simple class for representing a point in a Cartesian coordinate system.
    """
    
    def __init__(self, x, y):
        """
        Create a new Point at x, y.
        """
        self.x = x
        self.y = y
        
    def translate(self, dx, dy):
        """
        Translate the point by dx and dy in the x and y direction.
        """
        self.x += dx
        self.y += dy
        
    def __str__(self):
        return("Point at [%f, %f]" % (self.x, self.y))
```

* To create a new instance of a class the first argument (the self reference) is skipped

```py
p1 = Point(0, 0) # this will invoke the __init__ method in the Point class
print(p1)         # this will invoke the __str__ method
```
`Point at [0.000000, 0.000000]`

* To invoke a class method in the class instance  p is like in java or javascript:

```py
print(p1)
p1.translate(0.25, 1.5)
print(p1)
```
```
Point at [0.000000, 0.000000]
Point at [0.250000, 1.500000]
```

* Note that calling class methods can modify the state of that particular class instance, but does not effect other class instances or any global variables. That is one of the nice things about object-oriented design:
  * code such as functions and related variables are grouped in separate and independent entities.

## Exceptions
* In Python errors are managed with a special language construct called "Exceptions". When errors occur exceptions can be raised, which interrupts the normal program flow and fallback to somewhere else in the code where the closest try-except statement is defined.
* To generate an exception we can use the `raise` statement, which takes an argument that must be an instance of the class BaseException or a class derived from it.

```py
raise Exception("description of the error")
```
```
---------------------------------------------------------------------------
Exception                                 Traceback (most recent call last)
<ipython-input-105-c32f93e4dfa0> in <module>
----> 1 raise Exception("description of the error")

Exception: description of the error
```

* A typical use of exceptions is to abort functions when some error condition occurs, for example:

```py
def my_function(arguments):

    if not verify(arguments):
        raise Exception("Invalid arguments")

    # rest of the code goes here
```
