---
layout: post
title:  "Computer Networks Summary"
date:   2021-04-11 00:51:00 +0200
categories: internet
tags: CSE1405
---
{% include math.html %}
<!--more-->

# Table of Contents
- [Table of Contents](#table-of-contents)
  - [Network Performance Metrics](#network-performance-metrics)
    - [Byte conversion](#byte-conversion)
    - [Speed](#speed)
  - [Network Layers](#network-layers)
    - [Open Systems Interconnections (OSI) Model](#open-systems-interconnections-osi-model)
    - [TCP/IP model](#tcpip-model)
  - [Error Detection](#error-detection)
    - [Parity bits and checksums](#parity-bits-and-checksums)
    - [Error Detection](#error-detection-1)
    - [Error correction](#error-correction)
    - [Parity bits](#parity-bits)
    - [Checksum](#checksum)
    - [Checksum in 1s complement](#checksum-in-1s-complement)
    - [Cyclic Redunancy Check (CRC)](#cyclic-redunancy-check-crc)
    - [Hamming code (n+k,n)](#hamming-code-nkn)
    - [Parity block](#parity-block)
      - [Sender](#sender)
      - [Receiver](#receiver)
    - [Overhead Analysis](#overhead-analysis)
    - [Burst Errors](#burst-errors)

## Network Performance Metrics
### Byte conversion
* \\(Byte=8\ bits\\)
* \\(KB=2^{10}\ bytes\\)
* \\(MB=2^{20}\ bytes\\)
* \\(GB=2^{30}\ bytes\\)
* \\(TB=2^{40}\ bytes\\) 

### Speed
* Bandwidth: **Amount of total data that can maximally be sent via a connection per time unit**. (Max throughput) i.e. 10MB/s
* Latency: **bit travel time** from A to B. i.e. 20ms
* file transmission time (i.e. ms): **Time it takes to send all** bits of the message: (buffer) + file size / transmission rate 
  * Transmission rate: **sent bits per unit of time** (usually the bandwidth or smaller)
* Packet Delivery Time (ms): file transmission time + latency
* Throughput (**data transmitted per unit** i.e. 5 MB/s): file size / packet delivery time
* Overhead percentage: supportive info/total data
  * Total data = goodput + supportive info
  * goodput: actual data
* Packet loss is associated with a probaiblity p
* Jitter: variance in transmission delay (in latency)
  * Data might have been lost and resent without it being apparent to the user in anything but jitter. 
* 

## Network Layers
![layers]({{ site.url }}/images/network_layers.PNG)
* Each layer is a "level of abstraction"
  * Provides "services" to the layers above and below
  * Create the illusion of direct communication (horizontal line between same level layers), but in reality the information goes down from the origin up to the destination
![illusion]({{ site.url }}/images/illusion_direct_communication.PNG)
  * Only the lowest layer is the one that does the actual communication
  * Middle layers on different machines can have totally different service implementations, we dont care as long as the message is unchanged

### Open Systems Interconnections (OSI) Model
* This "model" divides the internet to diverse protocols (illusory direct communication between layers)
  * Each protocol is assigned to each layer

1. **Physical Layer** (lowest layer): Sends one bit via a physical medium, called a link
  * such physical medium can be an (ethernet) cable or a Wifi frequency
2. **Data link layer**: Sends a sequence of bits over a link *reliably*.
  * The pysical layer has a lot of errors (1 gets flipped into a 0 or viceversa or some data is lost during transmission). This layer deals with these errors so that the next layer doesnt even notice them.
    * **The MAC-Sublayer** regulates shared access to a (physical) medium, such as a wifi router. When multiple users are using a router, this sublayer manages how it is shared so that everybody can use it in a fair manner. MAC = medium access control
3. **Network layer**: Such as a LAN network or even the entire internet. This layer executes the sending of data from a source to a destination, which might be on the same network or on a different network.
4. **Transport layer**: The network layer has similar problems as the physical layer, where data is corrupted or lost, but at a higher level (i.e. sockets rather than single bits). This layer manages these problems and either decides to fix them or to ignore them (such as in a live videocall, where you do not want longer delays and rather have a potato but fast frames per second rather than HD frames per minute...). This is layer and upward ones only exist on the end hosts machines (i.e. the router has no longer nothing to do with). Therefore the source and destination only receive inderect feedback in the form of whether the packages have been received or not.
5. **Aplication layer** (highest level): These are protocols that deal with sending application specific information (email, web, instant messaging, games...)
  * The original OSI model actually has 2 additional layers between transport and application layer (5. Session and 6. Pressentation), but have no dedicated protocols and in practice the roles of these layers have been merged into either transport or application layers.
![communication]({{ site.url }}/images/communication_between_machines.PNG)
* Host stands for both source and destination parties
  * The data that a host sends is first forwared to the lowest layers on its machine (network, data link, physical)
  * Each of these apply some "preparing" tasks if needed, then send to the router, which then sends the data to another router (who may send it to another one and so on until reaching the destination router), who will pump the information up to the higher layers who will forward it to the correct application layer. (i.e. whatsapp messages should be sent to the whatsapp app used by the phone with the corresponding local IP address)

### TCP/IP model
* Whereas the OSI model (especially the original one that included Session and Presnetation) is a platonic model of what the ideal communication layers would look like, the TCP/IP model looked at the protocols that exist in practice and based on the ones being used it came up with:
![tcpip]({{ site.url }}/images/tcpip.PNG)
* It is practically the same but it officially removes the presentation and session layers, renames Network for Internet, and merges Data link and Pysical into Host-to-network (sometimes called the link layer). The reason of the merging is because even though OSI initially let each layer to be implemented independently, the wifi (pyhisical) was so irreliable that it was easier to enforce that all wifi layers are uniformly consistent with the data link layer so that errors are more intuitive and easier to handle.

## Error Detection
### Parity bits and checksums
* Checks for errors in the network. Possible causes are:
  * Errors between the client side wifi router and the machine
  * Errors in one of the multiple wifi routers on the server side
* Possible types of errors:
  * Bit could be flipped
    * Bit flip algorithms
  * Truncated/lost bits
    * Solution: Sender and reciver keep track of how much quantity they have sent and received

### Error Detection
1. Receipient detects an error
2. Recipient tells sender that error has been found, requests resend
3. Sender has to resend the data

### Error correction
1. Recepitent detects an error
2. Recipient is smart enough to fix it on its own

Both detection and correction are only possible by adding extra information to the messages which can allow to detect for errors.

Detection increasesy accuracy but increases latency and band-width usage whereas correction does the opposite.

### Parity bits
* A binary sequence has either even or odd parity (if it has an even/odd number of 1s)
* Parity bit algorithm: Sender and receiver agree on a fixed parity for all messages
  * Sender adds bit to message to get desired parity (appended to the right)
  * If parity is different then message must have been corrupted (however, keeping the same parity does not guarantee a successful message)
  * Algorithm can only detect odd number of bit flips

### Checksum
* Divides bits into groups of k-bits. Assume k=4.
* Computes the binary sum (bitwise xor) of all the blocks (last carried over bit is ignored)
* Appends the sum to the recepient
* The bitwise sum of the recepient which includes the appended sum should be all zeros (111 XOR 111 = 000), if not, then there was an error

### Checksum in 1s complement
* It's the same but in the XOR addition a row of all 1's is also added such that the appended checksum, when added to all the other k-sized blocks, returns all 1's instead of all 0's

### Cyclic Redunancy Check (CRC)
* Long division with remainder for binary numbers Uses a polynomial interpretation for each of the digits of a number, therefore there is like addition with no carryover (at all)
  * \\(x^3+x^2+x+1\\)

![binary_division]({{ site.url }}/images/binary_division.PNG)
* The data is the numerator and "error" is the denominator (different errors can find different amount of flipped bits)
  * CRC cannot detect any errors where the error is a multiple of generator
* The error denominator is chosen such that the remainder is 0
* When the receiver computes the division, if the remainder is not zero then it has detected an error
* There can be undetected errors if the changed bits come from the data + multiple of error

![crc_fn]({{ site.url }}/images/crc_fn.PNG)

### Hamming code (n+k,n)
* Like the previous techniques were extra bits provide information that allows an algorithm to correct certain errors. Hamming Codes have two numbers:
  * n: bit length of the original data/message (d3 = data bit 1)
  * k: number of extra bits and their parity (the size of k is determined by n) (p1 = parity of slot 1)

Example: 10011010

a. Sender allocates n+k slots and enamurate the slots from the left starting at 1.

| p1| p2| d3| p4| d5| d6| d7| p8| d9|d10|d11|d12|
|---|---|---|---|---|---|---|---|---|---|---|---|
|   |   |   |   |   |   |   |   |   |   |   |   |

b. The sender copies the n-bit message into slots that are NOT powers of two.

| p1| p2| d3| p4| d5| d6| d7| p8| d9|d10|d11|d12|
|---|---|---|---|---|---|---|---|---|---|---|---|
|   |   | 1 |   | 0 | 0 | 1 |   | 1 | 0 | 1 | 0 |

c. The other slots have the parity of a sequence of bits, depending on the position of the parity bit.
   *  p1 checks the parity of odd numbers, and converts itself to 1 or 0 to keep the XOR sum = 0
      *  p1+1+0+1+1+1=p1+0, p1=0

| p1| p2| d3| p4| d5| d6| d7| p8| d9|d10|d11|d12|
|---|---|---|---|---|---|---|---|---|---|---|---|
| 0 |   | 1 |   | 0 | 0 | 1 |   | 1 | 0 | 1 | 0 |

  * p2 checks 2 bits, skip 2 bits, formally checks the parity of binary numbers whose second bit is "ON", i.e. 00**1**0,00**1**1,01**1**0,01**1**1,10**1**0,10**1**1,11**1**0,11**1**1=(2,3,6,7,10,11,14,15)
    * p2 = p2+1+0+1+0+1=p2+1,p2=1

| p1| p2| d3| p4| d5| d6| d7| p8| d9|d10|d11|d12|
|---|---|---|---|---|---|---|---|---|---|---|---|
| 0 | 1 | 1 |   | 0 | 0 | 1 |   | 1 | 0 | 1 | 0 |

  * pn checks the parity of binary numbers whose k bit is "ON"...
  * p4 is k-bit number 3, so 100,101... =  4,5,6,7,12,13,14,15
    * p4+0+0+1+0=p4+1,p4=1

| p1| p2| d3| p4| d5| d6| d7| p8| d9|d10|d11|d12|
|---|---|---|---|---|---|---|---|---|---|---|---|
| 0 | 1 | 1 | 1 | 0 | 0 | 1 |   | 1 | 0 | 1 | 0 |

   * p8 is k-bit number 4 so 8-15, 24-31...

| p1| p2| d3| p4| d5| d6| d7| p8| d9|d10|d11|d12|
|---|---|---|---|---|---|---|---|---|---|---|---|
| 0 | 1 | 1 | 1 | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 0 |

d. Receiver flips those bits whose parity doesnt match
* error at d10

| p1| p2| d3| p4| d5| d6| d7| p8| d9|d10|d11|d12|
|---|---|---|---|---|---|---|---|---|---|---|---|
| 0 | 1 | 1 | 1 | 0 | 0 | 1 | 0 | 1 | **1** | 1 | 0 |

* Manually check the parity of all parity bits again
  * p2 is flipped
  * p8 is also fipped
  * 2+8=10, d10 is the bad bit

### Parity block
#### Sender
* Arrange the message in r by c bits matrix
* Compute the parity bits for all rows and columns respectively
* The corner bit is the parity of all bits, it has the same parity as the row and the column parity bits

![parity_block]({{ site.url }}/images/parity_block.PNG)
#### Receiver
* Assumes there was at most one bit flip
* Computes the parity bits for all rows and columns and finds the coordinates of the flipped bit and flips it

![fix_block]({{ site.url }}/images/fix_block.PNG)

* We can use the column/rows bit and corner bit to check if the flip was in the appended parity bits rather than in the data. These may be fixed depending on whether we forward these parity bits or not.

### Overhead Analysis
* Overhead: amount of extra information required by protocol in comparision to actual data
  * If for 100byte of data you have 1byte of appended information then you have a 1% overhead with O(n)
* Parity blocks have an overhead of r+c+1 bits
* Use derivative to minimize overhead

![fix_block]({{ site.url }}/images/overhead.PNG)

* This has asymptotic complexity of \\(O\sqrt{n}\\)
* Hamming Code has n+k bits overhead
* The asymptotic complexity is \\(O(log(n))\\)

![fix_block]({{ site.url }}/images/hc_overhead.PNG)

* Both parityblocks and hamming code can only correct 1 bit flip. There are other algorithms that can flip more bits, but none of the standard network protocols use them.

### Burst Errors
* Errors typically occur in bursts, so if one bit is flippied there is a high probability the next one is flipped as well
* We can mitigate error bursts by arranging the data in columns and rows and assigning a sepearate hamming code algorithm to teach column and row, which then only has to handle 1 flipped bit at a time