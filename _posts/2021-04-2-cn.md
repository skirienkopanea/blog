---
layout: post
title:  "Computer Networks Summary"
date:   2021-04-11 00:51:00 +0200
categories: internet
tags: CSE1405
---
{% include math.html %}
<!--more-->

# Table of Contents
- [Table of Contents](#table-of-contents)
  - [Network Layers](#network-layers)
    - [Open Systems Interconnections (OSI) Model](#open-systems-interconnections-osi-model)
    - [TCP/IP model](#tcpip-model)
  - [Error Detection](#error-detection)
    - [Parity bits and checksums](#parity-bits-and-checksums)
    - [Error Detection](#error-detection-1)
    - [Error correction](#error-correction)
    - [Parity bits](#parity-bits)
    - [Checksum](#checksum)
    - [Checksum in 1s complement](#checksum-in-1s-complement)

## Network Layers
![layers]({{ site.url }}/images/network_layers.PNG)
* Each layer is a "level of abstraction"
  * Provides "services" to the layers above and below
  * Create the illusion of direct communication (horizontal line between same level layers), but in reality the information goes down from the origin up to the destination
![illusion]({{ site.url }}/images/illusion_direct_communication.PNG)
  * Only the lowest layer is the one that does the actual communication
  * Middle layers on different machines can have totally different service implementations, we dont care as long as the message is unchanged

### Open Systems Interconnections (OSI) Model
* This "model" divides the internet to diverse protocols (illusory direct communication between layers)
  * Each protocol is assigned to each layer

1. **Physical Layer** (lowest layer): Sends one bit via a physical medium, called a link
  * such physical medium can be an (ethernet) cable or a Wifi frequency
2. **Data link layer**: Sends a sequence of bits over a link *reliably*.
  * The pysical layer has a lot of errors (1 gets flipped into a 0 or viceversa or some data is lost during transmission). This layer deals with these errors so that the next layer doesnt even notice them.
    * **The MAC-Sublayer** regulates shared access to a (physical) medium, such as a wifi router. When multiple users are using a router, this sublayer manages how it is shared so that everybody can use it in a fair manner. MAC = medium access control
3. **Network layer**: Such as a LAN network or even the entire internet. This layer executes the sending of data from a source to a destination, which might be on the same network or on a different network.
4. **Transport layer**: The network layer has similar problems as the physical layer, where data is corrupted or lost, but at a higher level (i.e. sockets rather than single bits). This layer manages these problems and either decides to fix them or to ignore them (such as in a live videocall, where you do not want longer delays and rather have a potato but fast frames per second rather than HD frames per minute...). This is layer and upward ones only exist on the end hosts machines (i.e. the router has no longer nothing to do with). Therefore the source and destination only receive inderect feedback in the form of whether the packages have been received or not.
5. **Aplication layer** (highest level): These are protocols that deal with sending application specific information (email, web, instant messaging, games...)
  * The original OSI model actually has 2 additional layers between transport and application layer (5. Session and 6. Pressentation), but have no dedicated protocols and in practice the roles of these layers have been merged into either transport or application layers.
![communication]({{ site.url }}/images/communication_between_machines.PNG)
* Host stands for both source and destination parties
  * The data that a host sends is first forwared to the lowest layers on its machine (network, data link, physical)
  * Each of these apply some "preparing" tasks if needed, then send to the router, which then sends the data to another router (who may send it to another one and so on until reaching the destination router), who will pump the information up to the higher layers who will forward it to the correct application layer. (i.e. whatsapp messages should be sent to the whatsapp app used by the phone with the corresponding local IP address)

### TCP/IP model
* Whereas the OSI model (especially the original one that included Session and Presnetation) is a platonic model of what the ideal communication layers would look like, the TCP/IP model looked at the protocols that exist in practice and based on the ones being used it came up with:
![tcpip]({{ site.url }}/images/tcpip.PNG)
* It is practically the same but it officially removes the presentation and session layers, renames Network for Internet, and merges Data link and Pysical into Host-to-network (sometimes called the link layer). The reason of the merging is because even though OSI initially let each layer to be implemented independently, the wifi (pyhisical) was so irreliable that it was easier to enforce that all wifi layers are uniformly consistent with the data link layer so that errors are more intuitive and easier to handle.

## Error Detection
### Parity bits and checksums
* Checks for errors in the network. Possible causes are:
  * Errors between the client side wifi router and the machine
  * Errors in one of the multiple wifi routers on the server side
* Possible types of errors:
  * Bit could be flipped
    * Bit flip algorithms
  * Truncated/lost bits
    * Solution: Sender and reciver keep track of how much quantity they have sent and received
### Error Detection
1. Receipient detects an error
2. Recipient tells sender that error has been found, requests resend
3. Sender has to resend the data

### Error correction
1. Recepitent detects an error
2. Recipient is smart enough to fix it on its own

Both detection and correction are only possible by adding extra information to the messages which can allow to detect for errors.

Detection increasesy accuracy but increases latency and band-width usage whereas correction does the opposite.

### Parity bits
* A binary sequence has either even or odd parity (if it has an even/odd number of 1s)
* Parity bit algorithm: Sender and receiver agree on a fixed parity for all messages
  * Sender adds bit to message to get desired parity (appended to the right)
  * If parity is different then message must have been corrupted (however, keeping the same parity does not guarantee a successful message)
  * Algorithm can only detect odd number of bit flips

### Checksum
* Divides bits into groups of k-bits. Assume k=4.
* Computes the binary sum (bitwise xor) of all the blocks (last carried over bit is ignored)
* Appends the sum to the recepient
* The bitwise sum of the recepient which includes the appended sum should be all zeros (111 XOR 111 = 000), if not, then there was an error

### Checksum in 1s complement
* It's the same but in the XOR addition a row of all 1's is also added such that the appended checksum, when added to all the other k-sized blocks, returns all 1's instead of all 0's