---
layout: post
title:  "Python Cheatsheet"
date:   2021-04-19 00:51:00 +0200
categories: python
tags: cheatsheet CSE1210
---
{% include math.html %}
<!--more-->

# Table of Contents
- [Table of Contents](#table-of-contents)
  - [Import CSV](#import-csv)
  - [Data visualization](#data-visualization)
    - [Graphical summaries](#graphical-summaries)
      - [Grouped bar chart](#grouped-bar-chart)
      - [Histogram](#histogram)
      - [Boxplot](#boxplot)
    - [Numerical summaries](#numerical-summaries)
  - [Simulate randomness](#simulate-randomness)
    - [Uniform distribution](#uniform-distribution)
    - [Discrete Gemoetric distribution](#discrete-gemoetric-distribution)
    - [Continous Exponential distribution](#continous-exponential-distribution)
  - [Bitwise operations](#bitwise-operations)

## Import CSV
* Reading files of the formats excel, SQL or CSV can be done using the library pandas.
* When you are sure the file is in the same directory as this notebook, you can use pd.read_csv to load the file into Python.
  * Use the extra argument sep=";" to separate the two columns of the dataset. 
* The command Heights.Class_1 now allows us to access the heights from classroom 1.
* For the documentation of pandas, see https://pandas.pydata.org/docs/index.html

```python
import pandas as pd

Height = pd.read_csv("Heights.csv", sep=";")
print(Height)
```

## Data visualization
### Graphical summaries
* In the library matplotlib.pyplot, there are various tools for making plots. 
* For documentation on matplotlib.pyplot, see
  * https://matplotlib.org/api/_as_gen/matplotlib.pyplot.plot.html
  * https://matplotlib.org/api/_as_gen/matplotlib.pyplot.hist.html

#### Grouped bar chart

![barchart]({{ site.url }}/images/py/barchart.png)

```python
import matplotlib.pyplot as plt
import numpy as np


labels = ['0', '1', '2', '3']
blue = [1/8, 3/8, 3/8,1/8]
orange = [1/8, 4/8, 7/8, 1]

x = np.arange(len(labels))  # the label locations
width = 0.35  # the width of the bars

fig, ax = plt.subplots()
rects1 = ax.bar(x - width/2, blue, width, label='probability function')
rects2 = ax.bar(x + width/2, orange, width, label='distribution function')

# Add some text for labels, title and custom x-axis tick labels, etc.
ax.set_ylabel('P(x)')
ax.set_title('X')
ax.set_xticks(x)
ax.set_xticklabels(labels)
ax.legend()

fig.tight_layout()

plt.show()
```
#### Histogram

* Use plt.hist to generate a histogram of the heights of the students of classroom 1. You can use a second argument bins = n to set the amount of bins used to n. Try to find a suitable amount of bins or set bins = 'auto' to automatically pick the bins based on the size of the data.

```python
import pandas as pd
import matplotlib.pyplot as plt

Height = pd.read_csv("Heights.csv", sep=";")
plt.hist(Height, bins=10)  # number of bins, not the size of the interval
# can use 'auto'
plt.show()
```

![histogram]({{ site.url }}/images/py/histogram.png)

* Using the command subplots we can make multiple plots in any desired order.
* Arguments like sharex and sharey allow you to ensure that all figures have the same axes.

```python
import pandas as pd
import matplotlib.pyplot as plt

Height = pd.read_csv("Heights.csv", sep=";")

fig, (ax1, ax2) = plt.subplots(1, 2, sharex=True, sharey=True, figsize=(15, 5))
ax1.hist(Height, bins='auto')
ax2.hist(Height, bins=5)
plt.show()
```
![subplots]({{ site.url }}/images/py/subplots.png)

#### Boxplot
* The function plt.boxplot allows us to generate boxplots of multiple datasets next to each other if formatted correctly.
* For documentation, see https://matplotlib.org/api/_as_gen/matplotlib.pyplot.boxplot.html

```python
import pandas as pd
import matplotlib.pyplot as plt

Height = pd.read_csv("Heights.csv", sep=";")

plt.boxplot(Height)
plt.xlabel("Classroom")
plt.ylabel("Height")
plt.show()
```
![boxplot]({{ site.url }}/images/py/boxplotpy.png)

### Numerical summaries
* from the library numpy, which is part of the library scipy that is used for most scientific operations and for all operations on arrays of data:
  * .mean
  * .min
  * .max
  * .sqrt
  * .exp
* For documentation, see https://docs.scipy.org/doc/numpy/user/index.html

```python
import pandas as pd
import numpy as np

Height = pd.read_csv("Heights.csv", sep=";")

print("The average height of Class_1 is ", np.mean(Height.Class_1))
```

## Simulate randomness
* To get the outcome of a dice throw, we use the np.random.choice function from the library numpy.

```python
import numpy as np

die = [1, 2, 3, 4, 5, 6]
probabilities = [1 / 6, 1 / 6, 1 / 6, 1 / 6, 1 / 6, 1 / 6]
outcome = np.random.choice(die, size=2, p=probabilities)

print("Outcome of the 2nd throw: ", outcome[1])

outcomes10 = np.random.choice(die, size=10, p=probabilities)
outcomes100 = np.random.choice(die, size=100, p=probabilities)
outcomes1000 = np.random.choice(die, size=1000, p=probabilities)

print("Average outcome after 10 throws: ", np.mean(outcomes10))
print("Average outcome after 100 throws: ", np.mean(outcomes100))
print("Average outcome after 1000 throws: ", np.mean(outcomes1000))
```
*The outcome does follow the law of large numbers*

```python
import matplotlib.pyplot as plt
import numpy as np

die = [1, 2, 3, 4, 5, 6]
probabilities = [1 / 6, 1 / 6, 1 / 6, 1 / 6, 1 / 6, 1 / 6]

fig, (ax1, ax2) = plt.subplots(1, 2, sharex=True, sharey=True, figsize=(15, 5))

outcomes = np.random.choice(die, size=1000, p=probabilities)
averages = [np.mean(outcomes[range(0, i)]) for i in range(1, 1001)]

plt.plot(averages)
plt.xlabel("n")
plt.ylabel("Average after n throws")
plt.show()
```
![bignumbers]({{ site.url }}/images/py/bignumbers.png)

### Uniform distribution
```python
import numpy as np
import matplotlib.pyplot as plt

from scipy.stats import uniform


def die_throw_rvs(sample_size=1):
    random_variables = np.zeros(sample_size)
    uniform_variables = uniform.rvs(size=sample_size)

    random_variables = np.ceil(uniform_variables * 6)

    return random_variables


distr = die_throw_rvs(100000)
print("max: ", np.max(distr), "min: ", np.min(distr), "mean: ", np.mean(distr), "variance: ", np.var(distr))
plt.hist(distr, bins='auto')  # arguments are passed to np.histogram
plt.title("Discrete uniform distribution")

plt.show()
```

![pydiscreteuniformdistribution]({{ site.url }}/images/py/pydiscreteuniformdistribution.png)

### Discrete Gemoetric distribution
```python
import numpy as np
import matplotlib.pyplot as plt

from scipy.stats import uniform


def die_throw_rvs(sample_size=1):
    random_variables = np.zeros(sample_size)
    uniform_variables = uniform.rvs(size=sample_size)
    random_variables = np.ceil(-1 / np.mean(uniform_variables) * np.log(uniform_variables))

    return random_variables


distr = die_throw_rvs(1000)
plt.hist(distr, bins='auto')  # arguments are passed to np.histogram
plt.title("Discrete geometric distribution")
plt.show()
```
![dgd]({{ site.url }}/images/py/dgd.png)

### Continous Exponential distribution
```python
import numpy as np
import matplotlib.pyplot as plt

from scipy.stats import uniform
from scipy.stats import gaussian_kde


def die_throw_rvs(sample_size=1):
    random_variables = np.zeros(sample_size)
    uniform_variables = uniform.rvs(size=sample_size)
    random_variables = -1 / np.mean(uniform_variables) * np.log(uniform_variables)

    return random_variables


distr = die_throw_rvs(100000)
density = gaussian_kde(distr)
xs = np.linspace(1, np.max(distr), 100)
density.covariance_factor = lambda: .25
density._compute_covariance()
plt.plot(xs, density(xs))
plt.title("Continous exponentional distribution")
plt.show()
```
![ced]({{ site.url }}/images/py/ced.png)

## Bitwise operations
```python


def run() -> None:
    """
    Bitwise operations
    """
    debugging()
    binary_notation()
    creating_bit_sequence()
    flipping_bit()
    prepending()
    appending()
    change_bit_sequence()
    inserting()


def debugging():
    # Showing binary representation of an integer value for debugging:
    integer_notation = 6
    binary_string_notation = format(integer_notation, 'b')
    print(str(integer_notation) + " -> " + binary_string_notation)
    return binary_string_notation


def binary_notation():
    # Creating integer from binary notation:
    integer1 = int("110", 2)
    integer2 = 0b110
    print(integer1)
    print(integer2)


def creating_bit_sequence():
    # Creating 010110001 (bit sequences) from scratch
    res = 0
    res |= 1 << 7  # or res = res | (1L << 7)
    res |= 1 << 5
    res |= 1 << 4
    res |= 1
    print(format(res, 'b'))


def flipping_bit():
    # Flipping a bit in 10(1)1 to become 10(0)1
    unflipped = 0b1011
    flipped = unflipped ^ (1 << 1)  # XOR original value with 10
    print(format(unflipped, 'b') + " -> " + format(flipped, 'b'))


def prepending():
    # Prepending the bit sequence 1101110 with 101
    original = 0b1101110
    prepended_value = 0b101
    prepended = original | (prepended_value << 7)
    print(format(original, 'b') + " -> " + format(prepended, 'b'))


def appending():
    # Appending the bit sequence 01110001 with 011
    original2 = 0b01110001
    appended_value = 0b011
    appended = original2 << 3 | appended_value
    print(format(original2, 'b') + " -> " + format(appended, 'b'))


def change_bit_sequence():
    # Changing the bit sequence 11(010)11 to 11(100)11
    unchanged = 0b1101011
    new_value = 0b100
    mask = 0b1100011  # Create a mask that selects the parts that need to remain
    changed = unchanged & mask  # Clear part to be changed
    changed |= (new_value << 2)  # Apply new value
    print(format(unchanged, 'b') + " -> " + format(changed, 'b'))


def inserting():
    # Inserting a '1' in between bit sequence 110011010 to become 110(1)011010
    uninserted = 0b110011010
    # Masks can be created using the creating bit sequences from scratch method
    mask1 = 0b111000000  # Mask to select first part
    mask2 = 0b000111111  # Mask to select second part
    tmp1 = ((mask1 & uninserted) << 1) | (mask2 & uninserted)  # Create a gap
    inserted = tmp1 | (1 << 6)  # Add the value 1000000
    print(format(uninserted, 'b') + " -> " + format(inserted, 'b'))
```